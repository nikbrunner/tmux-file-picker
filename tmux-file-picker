#!/usr/bin/env bash
set -euo pipefail

main() {
	if [[ -z "${TMUX-}" ]]; then
		echo "Error: This script must be run inside a tmux session." >&2
		exit 1
	fi

	local pane_id
	local pane_dir
	local pane_pid
	pane_id=$(tmux display-message -p '#{pane_id}')
	pane_dir=$(tmux display-message -p '#{pane_current_path}')
	pane_pid=$(tmux display-message -p '#{pane_pid}')

	# --- Argument Parsing ---
	local use_git_root=false
	local path_arg=""

	while [[ $# -gt 0 ]]; do
		case "$1" in
			--git-root|-g)
				use_git_root=true
				shift
				;;
			-*)
				echo "Error: Unknown option '$1'" >&2
				exit 1
				;;
			*)
				if [[ -n "$path_arg" ]]; then
					echo "Error: Only one path argument is allowed." >&2
					exit 1
				fi
				path_arg="$1"
				shift
				;;
		esac
	done

	local search_dir="${path_arg:-$pane_dir}"

	# Convert to absolute path if relative
	if [[ ! "$search_dir" = /* ]]; then
		search_dir="$pane_dir/$search_dir"
	fi

	# Use realpath to resolve ".." and "." components and get a canonical path
	local realpath_cmd="realpath"
	[[ "$OSTYPE" == "darwin"* ]] && realpath_cmd="grealpath"

	if command -v "$realpath_cmd" >/dev/null 2>&1; then
		search_dir=$("$realpath_cmd" -m "$search_dir")
	fi

	# Verify the directory exists
	if [[ ! -d "$search_dir" ]]; then
		echo "Error: Directory '$search_dir' does not exist." >&2
		exit 1
	fi

	# --- Mode Detection ---
	local at_prefix_mode=false
	local backtick_mode=false

	if pgrep -P "$pane_pid" -f ".*claude.*|node.*gemini|codex" >/dev/null; then
		at_prefix_mode=true
	elif pgrep -P "$pane_pid" -f ".*nvim.*|.*vim.*" >/dev/null; then
		backtick_mode=true
	fi

	local git_root
	git_root=$(git rev-parse --show-toplevel 2>/dev/null || true)
	if $use_git_root && [[ -z "$git_root" ]]; then
		echo "Error: --git-root flag used, but not inside a git repository." >&2
		exit 1
	fi

	# --- Command Detection ---
	local fd_cmd
	if command -v fd >/dev/null 2>&1; then
		fd_cmd="fd"
	elif command -v fdfind >/dev/null 2>&1; then
		fd_cmd="fdfind"
	else
		echo "Error: Required command 'fd' or 'fdfind' not found. Please install it." >&2
		exit 1
	fi

	# --- File Selection ---
	local preview_cmd="cat {}"
	if command -v bat >/dev/null 2>&1; then
		preview_cmd="bat --style=numbers --color=always {}"
	elif command -v batcat >/dev/null 2>&1; then
		preview_cmd="batcat --style=numbers --color=always {}"
	fi

	# Allow passing additional fd flags through environment variable
	local fd_flags="${TMUX_FILE_PICKER_FD_FLAGS:--H --type f --exclude .git}"
	local fd_flags_no_ignore="$fd_flags --no-ignore"

	# Helper to list files with git status prefix (dirty files first, deduped)
	# Format: "XY<tab>filename" where XY is git status (or spaces for clean files)
	# Uses marker line to separate git status from fd output for proper deduping
	# Colors: blue=modified, green=added, red=deleted, cyan=untracked
	local list_files_awk='
		BEGIN {
			reset = "\033[0m"
			blue = "\033[38;2;96;165;250m"    # #60A5FA
			green = "\033[38;2;74;222;128m"   # #4ADE80
			red = "\033[38;2;248;113;113m"    # #F87171
			cyan = "\033[38;2;34;211;238m"    # #22D3EE
		}
		/^---GIT_END---$/ { in_fd = 1; next }
		!in_fd {
			status = substr($0, 1, 2)
			file = substr($0, 4)
			# Strip quotes from filenames (git quotes names with spaces)
			gsub(/^"|"$/, "", file)
			# Color based on status
			if (status ~ /\?/) color = cyan
			else if (status ~ /A/) color = green
			else if (status ~ /D/) color = red
			else if (status ~ /[MRC]/) color = blue
			else color = ""
			if (color) print color status reset "\t" file
			else print status "\t" file
			seen[file] = 1
		}
		in_fd && !seen[$0] { print "  \t" $0 }
	'
	local list_files_cmd="{ git status --porcelain 2>/dev/null; echo '---GIT_END---'; $fd_cmd $fd_flags; } | awk '$list_files_awk'"
	local list_files_cmd_no_ignore="{ git status --porcelain 2>/dev/null; echo '---GIT_END---'; $fd_cmd $fd_flags_no_ignore; } | awk '$list_files_awk'"

	# Create temp files to track state changes
	local dir_file
	dir_file=$(mktemp)
	echo "$search_dir" > "$dir_file"

	local dir_mode_file
	dir_mode_file=$(mktemp)
	echo "false" > "$dir_mode_file"

	# Build directory preview command
	local dir_preview_cmd='ls -ap --color=always {}'
	if command -v tree >/dev/null 2>&1; then
		dir_preview_cmd='tree -C {} | head -n 30'
	fi

	# Create a temp script for the directory picker (avoids fzf escaping issues)
	local dir_picker_script
	dir_picker_script=$(mktemp)
	cat > "$dir_picker_script" << PICKER_EOF
#!/usr/bin/env bash
selected=\$($fd_cmd -H --type d --max-depth 10 --exclude .git . ~ | fzf --reverse --preview '$dir_preview_cmd')
if [[ -n "\$selected" ]]; then
    printf '%s' "\$selected"
fi
PICKER_EOF
	chmod +x "$dir_picker_script"
	trap "rm -f '$dir_file' '$dir_mode_file' '$dir_picker_script'" EXIT

	local header_line="ALT-I: gitignore | CTRL-D: chdir | ALT-ENTER: dir path"

	# Build fzf command with toggle binding for gitignore
	# Uses transform action with FZF_PROMPT to track state
	# Ctrl-D opens directory picker and reloads files from selected directory
	# Alt-Enter outputs directory path instead of file path
	local fzf_header="$search_dir
$header_line"
	local fzf_opts=(
		--multi
		--reverse
		--ansi
		--delimiter=$'\t'
		--preview "${preview_cmd/\{\}/\{2\}}"
		--prompt 'gitignore:ON> '
		--bind "alt-i:transform:[[ ! \$FZF_PROMPT =~ ON ]] &&
		    echo \"change-prompt(gitignore:ON> )+reload($list_files_cmd)\" ||
		    echo \"change-prompt(gitignore:OFF> )+reload($list_files_cmd_no_ignore)\""
		--bind "ctrl-d:execute($dir_picker_script > '$dir_file')+reload($fd_cmd $fd_flags --absolute-path . \"\$(cat '$dir_file')\" | sed 's/^/  \t/')+transform:[[ -s '$dir_file' ]] && echo \"change-header(\$(cat '$dir_file')
$header_line)\""
		--bind "alt-enter:execute-silent(echo true > '$dir_mode_file')+accept"
	)

	if $backtick_mode; then
		fzf_header="$search_dir
ALT-I: gitignore | CTRL-D: chdir | ALT-ENTER: dir | CTRL-E: nvim"
		fzf_opts+=(--bind "ctrl-e:execute-silent(tmux send-keys -t $pane_id Escape :e Space {2} Enter)+abort")
	fi

	local selected_files_str
	selected_files_str=$(cd "$search_dir" && \
		eval "$list_files_cmd" | \
		fzf "${fzf_opts[@]}" --header "$fzf_header" \
		|| true)

	# Check if directory was changed via Ctrl-D
	local final_search_dir
	final_search_dir=$(cat "$dir_file")
	local dir_was_changed=false
	if [[ "$final_search_dir" != "$search_dir" ]]; then
		dir_was_changed=true
		search_dir="$final_search_dir"
	fi

	# Check if directory mode was requested via Alt-Enter
	local dir_mode=false
	if [[ "$(cat "$dir_mode_file")" == "true" ]]; then
		dir_mode=true
	fi

	if [[ -z "$selected_files_str" ]]; then
		exit 0
	fi

	# --- Path Processing ---
	# Strip the git status prefix (format: "XY<tab>filename" -> "filename")
	selected_files=()
	while IFS= read -r line; do
		if [[ -n "$line" ]]; then
			# Remove everything up to and including the tab
			selected_files+=("${line#*$'\t'}")
		fi
	done <<<"$selected_files_str"

	# --- Path Relativization ---
	local relative_paths=()

	# When directory was changed via Ctrl-D, files are already absolute paths
	if $dir_was_changed; then
		relative_paths=("${selected_files[@]}")
	else
		# Standard path relativization logic
		local base_dir_for_relativization=""

		if $use_git_root; then
			base_dir_for_relativization="$git_root"
		elif [[ "$search_dir" != "$pane_dir" ]]; then
			base_dir_for_relativization="$pane_dir"
		fi

		if [[ -n "$base_dir_for_relativization" ]]; then
			# We need to calculate relative paths against a specific base directory
			local realpath_cmd="realpath"
			[[ "$OSTYPE" == "darwin"* ]] && realpath_cmd="grealpath"

			# Prepend search directory to each filename to create full paths
			local full_paths=("${selected_files[@]/#/$search_dir\/}")

			while IFS= read -r line; do
				if [[ -n "$line" ]]; then
					relative_paths+=("$line")
				fi
			done < <("$realpath_cmd" --relative-to="$base_dir_for_relativization" "${full_paths[@]}")
		else
			# Paths are already relative to the correct directory (the pane_dir)
			relative_paths=("${selected_files[@]}")
		fi
	fi

	# --- Directory Mode Processing ---
	# If Alt-Enter was pressed, convert file paths to their directory paths
	if $dir_mode; then
		local dir_paths=()
		for path in "${relative_paths[@]}"; do
			dir_paths+=("$(dirname "$path")")
		done
		# Remove duplicates while preserving order
		local unique_dirs=()
		local -A seen=()
		for dir in "${dir_paths[@]}"; do
			if [[ -z "${seen[$dir]:-}" ]]; then
				seen[$dir]=1
				unique_dirs+=("$dir")
			fi
		done
		relative_paths=("${unique_dirs[@]}")
	fi

	# --- Output Formatting ---
	local files_oneline
	if $at_prefix_mode; then
		# Prefix each file with '@' and join with spaces
		printf -v files_oneline "@%s " "${relative_paths[@]}"
	elif $backtick_mode; then
		# Wrap each file in backticks and join with spaces
		local backticked_paths=()
		for path in "${relative_paths[@]}"; do
			backticked_paths+=("\`$path\`")
		done
		files_oneline=$(printf "%s " "${backticked_paths[@]}")
	else
		# Shell-escape each file path and join with spaces
		local escaped_paths=()
		for path in "${relative_paths[@]}"; do
			printf -v escaped_path "%q" "$path"
			escaped_paths+=("$escaped_path")
		done
		files_oneline=$(printf "%s " "${escaped_paths[@]}")
	fi

	# --- Send to Tmux ---
	tmux send-keys -t "$pane_id" "$files_oneline"
}

main "$@"
